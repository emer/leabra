// Code generated by "core generate"; DO NOT EDIT.

package deep

import (
	"cogentcore.org/core/gti"
)

var _ = gti.AddType(&gti.Type{Name: "github.com/emer/leabra/v2/deep.CTLayer", IDName: "ct-layer", Doc: "CTLayer implements the corticothalamic projecting layer 6 deep neurons\nthat project to the TRC pulvinar neurons, to generate the predictions.\nThey receive phasic input representing 5IB bursting via CTCtxtPrjn inputs\nfrom SuperLayer and also from self projections.", Embeds: []gti.Field{{Name: "TopoInhibLayer"}}, Fields: []gti.Field{{Name: "BurstQtr", Doc: "Quarter(s) when bursting occurs -- typically Q4 but can also be Q2 and Q4 for beta-frequency updating.  Note: this is a bitflag and must be accessed using its Set / Has etc routines, 32 bit versions."}, {Name: "CtxtGes", Doc: "slice of context (temporally delayed) excitatory conducances."}}})

var _ = gti.AddType(&gti.Type{Name: "github.com/emer/leabra/v2/deep.CtxtSender", IDName: "ctxt-sender", Doc: "CtxtSender is an interface for layers that implement the SendCtxtGe method\n(SuperLayer, CTLayer)"})

var _ = gti.AddType(&gti.Type{Name: "github.com/emer/leabra/v2/deep.CTCtxtPrjn", IDName: "ct-ctxt-prjn", Doc: "CTCtxtPrjn is the \"context\" temporally-delayed projection into CTLayer,\n(corticothalamic deep layer 6) where the CtxtGe excitatory input\nis integrated only at end of Burst Quarter.\nSet FmSuper for the main projection from corresponding Super layer.", Embeds: []gti.Field{{Name: "Prjn"}}, Fields: []gti.Field{{Name: "FmSuper", Doc: "if true, this is the projection from corresponding Superficial layer -- should be OneToOne prjn, with Learn.Learn = false, WtInit.Var = 0, Mean = 0.8 -- these defaults are set if FmSuper = true"}, {Name: "CtxtGeInc", Doc: "local per-recv unit accumulator for Ctxt excitatory conductance from sending units -- not a delta -- the full value"}}})

var _ = gti.AddType(&gti.Type{Name: "github.com/emer/leabra/v2/deep.PrjnType", IDName: "prjn-type", Doc: "PrjnType has the DeepLeabra extensions to the emer.PrjnType types, for gui"})

var _ = gti.AddType(&gti.Type{Name: "github.com/emer/leabra/v2/deep.LayerType", IDName: "layer-type", Doc: "LayerType has the DeepLeabra extensions to the emer.LayerType types, for gui"})

var _ = gti.AddType(&gti.Type{Name: "github.com/emer/leabra/v2/deep.Network", IDName: "network", Doc: "deep.Network has parameters for running a DeepLeabra network", Embeds: []gti.Field{{Name: "Network"}}})

var _ = gti.AddType(&gti.Type{Name: "github.com/emer/leabra/v2/deep.SuperNeuron", IDName: "super-neuron", Doc: "SuperNeuron has the neuron values for SuperLayer", Fields: []gti.Field{{Name: "Burst", Doc: "5IB bursting activation value, computed by thresholding regular activation"}, {Name: "BurstPrv", Doc: "previous bursting activation -- used for context-based learning"}, {Name: "Attn", Doc: "attentional signal from TRC layer"}}})

var _ = gti.AddType(&gti.Type{Name: "github.com/emer/leabra/v2/deep.EPool", IDName: "e-pool", Doc: "EPool are how to gather excitation across pools", Fields: []gti.Field{{Name: "LayNm", Doc: "layer name"}, {Name: "Wt", Doc: "general scaling factor for how much excitation from this pool"}}})

var _ = gti.AddType(&gti.Type{Name: "github.com/emer/leabra/v2/deep.EPools", IDName: "e-pools", Doc: "EPools is a list of pools"})

var _ = gti.AddType(&gti.Type{Name: "github.com/emer/leabra/v2/deep.IPool", IDName: "i-pool", Doc: "IPool are how to gather inhibition across pools", Fields: []gti.Field{{Name: "LayNm", Doc: "layer name"}, {Name: "Wt", Doc: "general scaling factor for how much overall inhibition from this pool contributes, in a non-pool-specific manner"}, {Name: "PoolWt", Doc: "scaling factor for how much corresponding pools contribute in a pool-spcific manner, using offsets and averaging across pools as needed to match geometry"}, {Name: "SOff", Doc: "offset into source, sending layer"}, {Name: "ROff", Doc: "offset into our own receiving layer"}}})

var _ = gti.AddType(&gti.Type{Name: "github.com/emer/leabra/v2/deep.IPools", IDName: "i-pools", Doc: "IPools is a list of pools"})

var _ = gti.AddType(&gti.Type{Name: "github.com/emer/leabra/v2/deep.BurstParams", IDName: "burst-params", Doc: "BurstParams determine how the 5IB Burst activation is computed from\nstandard Act activation values in SuperLayer -- thresholded.", Fields: []gti.Field{{Name: "BurstQtr", Doc: "Quarter(s) when bursting occurs -- typically Q4 but can also be Q2 and Q4 for beta-frequency updating.  Note: this is a bitflag and must be accessed using its Set / Has etc routines, 32 bit versions."}, {Name: "ThrRel", Doc: "Relative component of threshold on superficial activation value, below which it does not drive Burst (and above which, Burst = Act).  This is the distance between the average and maximum activation values within layer (e.g., 0 = average, 1 = max).  Overall effective threshold is MAX of relative and absolute thresholds."}, {Name: "ThrAbs", Doc: "Absolute component of threshold on superficial activation value, below which it does not drive Burst (and above which, Burst = Act).  Overall effective threshold is MAX of relative and absolute thresholds."}}})

var _ = gti.AddType(&gti.Type{Name: "github.com/emer/leabra/v2/deep.TRCAttnParams", IDName: "trc-attn-params", Doc: "TRCAttnParams determine how the TRCLayer activation modulates SuperLayer activations", Fields: []gti.Field{{Name: "On", Doc: "is attentional modulation active?"}, {Name: "Min", Doc: "minimum act multiplier if attention is 0"}, {Name: "TRCLay", Doc: "name of TRC layer -- defaults to layer name + P"}}})

var _ = gti.AddType(&gti.Type{Name: "github.com/emer/leabra/v2/deep.SuperLayer", IDName: "super-layer", Doc: "SuperLayer is the DeepLeabra superficial layer, based on basic rate-coded leabra.Layer.\nComputes the Burst activation from regular activations.", Embeds: []gti.Field{{Name: "TopoInhibLayer"}}, Fields: []gti.Field{{Name: "Burst", Doc: "parameters for computing Burst from act, in Superficial layers (but also needed in Deep layers for deep self connections)"}, {Name: "Attn", Doc: "determine how the TRCLayer activation modulates SuperLayer feedforward excitatory conductances, representing TRC effects on layer V4 inputs (not separately simulated) -- must have a valid layer."}, {Name: "SuperNeurs", Doc: "slice of super neuron values -- same size as Neurons"}}})

var _ = gti.AddType(&gti.Type{Name: "github.com/emer/leabra/v2/deep.TopoInhib", IDName: "topo-inhib", Doc: "TopoInhib provides for topographic gaussian inhibition integrating over neighborhood.\nEffective inhibition is", Fields: []gti.Field{{Name: "On", Doc: "use topographic inhibition"}, {Name: "Width", Doc: "half-width of topographic inhibition within layer"}, {Name: "Sigma", Doc: "normalized gaussian sigma as proportion of Width, for gaussian weighting"}, {Name: "Gi", Doc: "overall inhibition multiplier for topographic inhibition (generally <= 1)"}, {Name: "LayGi", Doc: "layer-level baseline inhibition factor for Max computation -- ensures a baseline inhib as proportion of maximum inhib within any single pool"}, {Name: "Wts", Doc: "gaussian weights as function of distance, precomputed.  index 0 = dist 1"}}})

var _ = gti.AddType(&gti.Type{Name: "github.com/emer/leabra/v2/deep.TopoInhibLayer", IDName: "topo-inhib-layer", Doc: "TopoInhibLayer is a layer with topographically organized inhibition among pools", Embeds: []gti.Field{{Name: "Layer"}}, Fields: []gti.Field{{Name: "TopoInhib", Doc: "topographic inhibition parameters for pool-level inhibition (only used for layers with pools)"}}})

var _ = gti.AddType(&gti.Type{Name: "github.com/emer/leabra/v2/deep.Driver", IDName: "driver", Doc: "Driver describes the source of driver inputs from cortex into TRC (pulvinar)", Fields: []gti.Field{{Name: "Driver", Doc: "driver layer"}, {Name: "Off", Doc: "offset into TRC pool"}}})

var _ = gti.AddType(&gti.Type{Name: "github.com/emer/leabra/v2/deep.Drivers", IDName: "drivers", Doc: "Drivers are a list of drivers"})

var _ = gti.AddType(&gti.Type{Name: "github.com/emer/leabra/v2/deep.TRCParams", IDName: "trc-params", Doc: "TRCParams provides parameters for how the plus-phase (outcome) state of thalamic relay cell\n(e.g., Pulvinar) neurons is computed from the corresponding driver neuron Burst activation.", Fields: []gti.Field{{Name: "DriversOff", Doc: "Turn off the driver inputs, in which case this layer behaves like a standard layer"}, {Name: "BurstQtr", Doc: "Quarter(s) when bursting occurs -- typically Q4 but can also be Q2 and Q4 for beta-frequency updating.  Note: this is a bitflag and must be accessed using its Set / Has etc routines"}, {Name: "DriveScale", Doc: "multiplier on driver input strength, multiplies activation of driver layer"}, {Name: "MaxInhib", Doc: "Level of Max driver layer activation at which the predictive non-burst inputs are fully inhibited.  Computationally, it is essential that driver inputs inhibit effect of predictive non-driver (CTLayer) inputs, so that the plus phase is not always just the minus phase plus something extra (the error will never go to zero then).  When max driver act input exceeds this value, predictive non-driver inputs are fully suppressed.  If there is only weak burst input however, then the predictive inputs remain and this critically prevents the network from learning to turn activation off, which is difficult and severely degrades learning."}, {Name: "NoTopo", Doc: "Do not treat the pools in this layer as topographically organized relative to driver inputs -- all drivers compress down to give same input to all pools"}, {Name: "AvgMix", Doc: "proportion of average across driver pools that is combined with Max to provide some graded tie-breaker signal -- especially important for large pool downsampling, e.g., when doing NoTopo"}, {Name: "Binarize", Doc: "Apply threshold to driver burst input for computing plus-phase activations -- above BinThr, then Act = BinOn, below = BinOff.  This is beneficial for layers with weaker graded activations, such as V1 or other perceptual inputs."}, {Name: "BinThr", Doc: "Threshold for binarizing in terms of sending Burst activation"}, {Name: "BinOn", Doc: "Resulting driver Ge value for units above threshold -- lower value around 0.3 or so seems best (DriveScale is NOT applied -- generally same range as that)."}, {Name: "BinOff", Doc: "Resulting driver Ge value for units below threshold -- typically 0."}}})

var _ = gti.AddType(&gti.Type{Name: "github.com/emer/leabra/v2/deep.TRCLayer", IDName: "trc-layer", Doc: "TRCLayer is the thalamic relay cell layer for DeepLeabra.\nIt has normal activity during the minus phase, as activated by CT etc inputs,\nand is then driven by strong 5IB driver inputs in the plus phase.\nFor attentional modulation, TRC maintains pool-level correspondence with CT inputs\nwhich creates challenges for aligning with driver inputs.\n  - Max operation used to integrate across multiple drivers, where necessary,\n    e.g., multiple driver pools map onto single TRC pool (common feedforward theme),\n    *even when there is no logical connection for the i'th unit in each pool* --\n    to make this dimensionality reduction more effective, using lateral connectivity\n    between pools that favors this correspondence is beneficial.  Overall, this is\n    consistent with typical DCNN max pooling organization.\n  - Typically, pooled 4D TRC layers should have fewer pools than driver layers,\n    in which case the respective pool geometry is interpolated.  Ideally, integer size\n    differences are best (e.g., driver layer has 2x pools vs TRC).\n  - Pooled 4D TRC layer should in general not predict flat 2D drivers, but if so\n    the drivers are replicated for each pool.\n  - Similarly, there shouldn't generally be more TRC pools than driver pools, but\n    if so, drivers replicate across pools.", Embeds: []gti.Field{{Name: "TopoInhibLayer"}}, Fields: []gti.Field{{Name: "TRC", Doc: "parameters for computing TRC plus-phase (outcome) activations based on Burst activation from corresponding driver neuron"}, {Name: "Drivers", Doc: "name of SuperLayer that sends 5IB Burst driver inputs to this layer"}}})

var _ = gti.AddType(&gti.Type{Name: "github.com/emer/leabra/v2/deep.TRNLayer", IDName: "trn-layer", Doc: "TRNLayer copies inhibition from pools in CT and TRC layers, and from other\nTRNLayers, and pools this inhibition using the Max operation", Embeds: []gti.Field{{Name: "Layer"}}, Fields: []gti.Field{{Name: "ILayers", Doc: "layers that we receive inhibition from"}}})
