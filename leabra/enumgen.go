// Code generated by "core generate -add-types"; DO NOT EDIT.

package leabra

import (
	"cogentcore.org/core/enums"
)

var _ActNoiseTypeValues = []ActNoiseType{0, 1, 2, 3, 4}

// ActNoiseTypeN is the highest valid value for type ActNoiseType, plus one.
const ActNoiseTypeN ActNoiseType = 5

var _ActNoiseTypeValueMap = map[string]ActNoiseType{`NoNoise`: 0, `VmNoise`: 1, `GeNoise`: 2, `ActNoise`: 3, `GeMultNoise`: 4}

var _ActNoiseTypeDescMap = map[ActNoiseType]string{0: `NoNoise means no noise added`, 1: `VmNoise means noise is added to the membrane potential. IMPORTANT: this should NOT be used for rate-code (NXX1) activations, because they do not depend directly on the vm -- this then has no effect`, 2: `GeNoise means noise is added to the excitatory conductance (Ge). This should be used for rate coded activations (NXX1)`, 3: `ActNoise means noise is added to the final rate code activation`, 4: `GeMultNoise means that noise is multiplicative on the Ge excitatory conductance values`}

var _ActNoiseTypeMap = map[ActNoiseType]string{0: `NoNoise`, 1: `VmNoise`, 2: `GeNoise`, 3: `ActNoise`, 4: `GeMultNoise`}

// String returns the string representation of this ActNoiseType value.
func (i ActNoiseType) String() string { return enums.String(i, _ActNoiseTypeMap) }

// SetString sets the ActNoiseType value from its string representation,
// and returns an error if the string is invalid.
func (i *ActNoiseType) SetString(s string) error {
	return enums.SetString(i, s, _ActNoiseTypeValueMap, "ActNoiseType")
}

// Int64 returns the ActNoiseType value as an int64.
func (i ActNoiseType) Int64() int64 { return int64(i) }

// SetInt64 sets the ActNoiseType value from an int64.
func (i *ActNoiseType) SetInt64(in int64) { *i = ActNoiseType(in) }

// Desc returns the description of the ActNoiseType value.
func (i ActNoiseType) Desc() string { return enums.Desc(i, _ActNoiseTypeDescMap) }

// ActNoiseTypeValues returns all possible values for the type ActNoiseType.
func ActNoiseTypeValues() []ActNoiseType { return _ActNoiseTypeValues }

// Values returns all possible values for the type ActNoiseType.
func (i ActNoiseType) Values() []enums.Enum { return enums.Values(_ActNoiseTypeValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i ActNoiseType) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *ActNoiseType) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "ActNoiseType")
}

var _QuartersValues = []Quarters{0, 1, 2, 3}

// QuartersN is the highest valid value for type Quarters, plus one.
const QuartersN Quarters = 4

var _QuartersValueMap = map[string]Quarters{`Q1`: 0, `Q2`: 1, `Q3`: 2, `Q4`: 3}

var _QuartersDescMap = map[Quarters]string{0: `Q1 is the first quarter, which, due to 0-based indexing, shows up as Quarter = 0 in timer`, 1: ``, 2: ``, 3: ``}

var _QuartersMap = map[Quarters]string{0: `Q1`, 1: `Q2`, 2: `Q3`, 3: `Q4`}

// String returns the string representation of this Quarters value.
func (i Quarters) String() string { return enums.BitFlagString(i, _QuartersValues) }

// BitIndexString returns the string representation of this Quarters value
// if it is a bit index value (typically an enum constant), and
// not an actual bit flag value.
func (i Quarters) BitIndexString() string { return enums.String(i, _QuartersMap) }

// SetString sets the Quarters value from its string representation,
// and returns an error if the string is invalid.
func (i *Quarters) SetString(s string) error { *i = 0; return i.SetStringOr(s) }

// SetStringOr sets the Quarters value from its string representation
// while preserving any bit flags already set, and returns an
// error if the string is invalid.
func (i *Quarters) SetStringOr(s string) error {
	return enums.SetStringOr(i, s, _QuartersValueMap, "Quarters")
}

// Int64 returns the Quarters value as an int64.
func (i Quarters) Int64() int64 { return int64(i) }

// SetInt64 sets the Quarters value from an int64.
func (i *Quarters) SetInt64(in int64) { *i = Quarters(in) }

// Desc returns the description of the Quarters value.
func (i Quarters) Desc() string { return enums.Desc(i, _QuartersDescMap) }

// QuartersValues returns all possible values for the type Quarters.
func QuartersValues() []Quarters { return _QuartersValues }

// Values returns all possible values for the type Quarters.
func (i Quarters) Values() []enums.Enum { return enums.Values(_QuartersValues) }

// HasFlag returns whether these bit flags have the given bit flag set.
func (i *Quarters) HasFlag(f enums.BitFlag) bool { return enums.HasFlag((*int64)(i), f) }

// SetFlag sets the value of the given flags in these flags to the given value.
func (i *Quarters) SetFlag(on bool, f ...enums.BitFlag) { enums.SetFlag((*int64)(i), on, f...) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Quarters) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Quarters) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "Quarters") }

var _LayerTypesValues = []LayerTypes{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18}

// LayerTypesN is the highest valid value for type LayerTypes, plus one.
const LayerTypesN LayerTypes = 19

var _LayerTypesValueMap = map[string]LayerTypes{`SuperLayer`: 0, `InputLayer`: 1, `TargetLayer`: 2, `CompareLayer`: 3, `CTLayer`: 4, `PulvinarLayer`: 5, `TRNLayer`: 6, `ClampDaLayer`: 7, `RWPredLayer`: 8, `RWDaLayer`: 9, `TDRewPredLayer`: 10, `TDRewIntegLayer`: 11, `TDDaLayer`: 12, `MatrixLayer`: 13, `GPeLayer`: 14, `GPiThalLayer`: 15, `CINLayer`: 16, `PFCLayer`: 17, `PFCDeepLayer`: 18}

var _LayerTypesDescMap = map[LayerTypes]string{0: `Super is a superficial cortical layer (lamina 2-3-4) which does not receive direct input or targets. In more generic models, it should be used as a Hidden layer, and maps onto the Hidden type in LayerTypes.`, 1: `Input is a layer that receives direct external input in its Ext inputs. Biologically, it can be a primary sensory layer, or a thalamic layer.`, 2: `Target is a layer that receives direct external target inputs used for driving plus-phase learning. Simple target layers are generally not used in more biological models, which instead use predictive learning via Pulvinar or related mechanisms.`, 3: `Compare is a layer that receives external comparison inputs, which drive statistics but do NOT drive activation or learning directly. It is rarely used in axon.`, 4: `CT are layer 6 corticothalamic projecting neurons, which drive &#34;top down&#34; predictions in Pulvinar layers. They maintain information over time via stronger NMDA channels and use maintained prior state information to generate predictions about current states forming on Super layers that then drive PT (5IB) bursting activity, which are the plus-phase drivers of Pulvinar activity.`, 5: `Pulvinar are thalamic relay cell neurons in the higher-order Pulvinar nucleus of the thalamus, and functionally isomorphic neurons in the MD thalamus, and potentially other areas. These cells alternately reflect predictions driven by CT pathways, and actual outcomes driven by 5IB Burst activity from corresponding PT or Super layer neurons that provide strong driving inputs.`, 6: `TRNLayer is thalamic reticular nucleus layer for inhibitory competition within the thalamus.`, 7: `ClampDaLayer is an Input layer that just sends its activity as the dopamine signal.`, 8: `RWPredLayer computes reward prediction for a simple Rescorla-Wagner learning dynamic (i.e., PV learning in the PVLV framework). Activity is computed as linear function of excitatory conductance (which can be negative -- there are no constraints). Use with [RWPath] which does simple delta-rule learning on minus-plus.`, 9: `RWDaLayer computes a dopamine (DA) signal based on a simple Rescorla-Wagner learning dynamic (i.e., PV learning in the PVLV framework). It computes difference between r(t) and [RWPredLayer] values. r(t) is accessed directly from a Rew layer -- if no external input then no DA is computed -- critical for effective use of RW only for PV cases. RWPred prediction is also accessed directly from Rew layer to avoid any issues.`, 10: `TDRewPredLayer is the temporal differences reward prediction layer. It represents estimated value V(t) in the minus phase, and computes estimated V(t+1) based on its learned weights in plus phase. Use [TDRewPredPath] for DA modulated learning.`, 11: `TDRewIntegLayer is the temporal differences reward integration layer. It represents estimated value V(t) in the minus phase, and estimated V(t+1) + r(t) in the plus phase. It computes r(t) from (typically fixed) weights from a reward layer, and directly accesses values from [TDRewPredLayer].`, 12: `TDDaLayer computes a dopamine (DA) signal as the temporal difference (TD) between the [TDRewIntegLayer[] activations in the minus and plus phase.`, 13: `MatrixLayer represents the dorsal matrisome MSN&#39;s that are the main Go / NoGo gating units in BG driving updating of PFC WM in PBWM. D1R = Go, D2R = NoGo, and outer 4D Pool X dimension determines GateTypes per MaintN (Maint on the left up to MaintN, Out on the right after)`, 14: `GPeLayer is a Globus pallidus external layer, a key region of the basal ganglia. It does not require any additional mechanisms beyond the SuperLayer.`, 15: `GPiThalLayer represents the combined Winner-Take-All dynamic of GPi (SNr) and Thalamus. It is the final arbiter of gating in the BG, weighing Go (direct) and NoGo (indirect) inputs from MatrixLayers (indirectly via GPe layer in case of NoGo). Use 4D structure for this so it matches 4D structure in Matrix layers`, 16: `CINLayer (cholinergic interneuron) reads reward signals from named source layer(s) and sends the Max absolute value of that activity as the positively rectified non-prediction-discounted reward signal computed by CINs, and sent as an acetylcholine (ACh) signal. To handle positive-only reward signals, need to include both a reward prediction and reward outcome layer.`, 17: `PFCLayer is a prefrontal cortex layer, either superficial or output. See [PFCDeepLayer] for the deep maintenance layer.`, 18: `PFCDeepLayer is a prefrontal cortex deep maintenance layer.`}

var _LayerTypesMap = map[LayerTypes]string{0: `SuperLayer`, 1: `InputLayer`, 2: `TargetLayer`, 3: `CompareLayer`, 4: `CTLayer`, 5: `PulvinarLayer`, 6: `TRNLayer`, 7: `ClampDaLayer`, 8: `RWPredLayer`, 9: `RWDaLayer`, 10: `TDRewPredLayer`, 11: `TDRewIntegLayer`, 12: `TDDaLayer`, 13: `MatrixLayer`, 14: `GPeLayer`, 15: `GPiThalLayer`, 16: `CINLayer`, 17: `PFCLayer`, 18: `PFCDeepLayer`}

// String returns the string representation of this LayerTypes value.
func (i LayerTypes) String() string { return enums.String(i, _LayerTypesMap) }

// SetString sets the LayerTypes value from its string representation,
// and returns an error if the string is invalid.
func (i *LayerTypes) SetString(s string) error {
	return enums.SetString(i, s, _LayerTypesValueMap, "LayerTypes")
}

// Int64 returns the LayerTypes value as an int64.
func (i LayerTypes) Int64() int64 { return int64(i) }

// SetInt64 sets the LayerTypes value from an int64.
func (i *LayerTypes) SetInt64(in int64) { *i = LayerTypes(in) }

// Desc returns the description of the LayerTypes value.
func (i LayerTypes) Desc() string { return enums.Desc(i, _LayerTypesDescMap) }

// LayerTypesValues returns all possible values for the type LayerTypes.
func LayerTypesValues() []LayerTypes { return _LayerTypesValues }

// Values returns all possible values for the type LayerTypes.
func (i LayerTypes) Values() []enums.Enum { return enums.Values(_LayerTypesValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i LayerTypes) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *LayerTypes) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "LayerTypes")
}

var _DaReceptorsValues = []DaReceptors{0, 1}

// DaReceptorsN is the highest valid value for type DaReceptors, plus one.
const DaReceptorsN DaReceptors = 2

var _DaReceptorsValueMap = map[string]DaReceptors{`D1R`: 0, `D2R`: 1}

var _DaReceptorsDescMap = map[DaReceptors]string{0: `D1R primarily expresses Dopamine D1 Receptors -- dopamine is excitatory and bursts of dopamine lead to increases in synaptic weight, while dips lead to decreases -- direct pathway in dorsal striatum`, 1: `D2R primarily expresses Dopamine D2 Receptors -- dopamine is inhibitory and bursts of dopamine lead to decreases in synaptic weight, while dips lead to increases -- indirect pathway in dorsal striatum`}

var _DaReceptorsMap = map[DaReceptors]string{0: `D1R`, 1: `D2R`}

// String returns the string representation of this DaReceptors value.
func (i DaReceptors) String() string { return enums.String(i, _DaReceptorsMap) }

// SetString sets the DaReceptors value from its string representation,
// and returns an error if the string is invalid.
func (i *DaReceptors) SetString(s string) error {
	return enums.SetString(i, s, _DaReceptorsValueMap, "DaReceptors")
}

// Int64 returns the DaReceptors value as an int64.
func (i DaReceptors) Int64() int64 { return int64(i) }

// SetInt64 sets the DaReceptors value from an int64.
func (i *DaReceptors) SetInt64(in int64) { *i = DaReceptors(in) }

// Desc returns the description of the DaReceptors value.
func (i DaReceptors) Desc() string { return enums.Desc(i, _DaReceptorsDescMap) }

// DaReceptorsValues returns all possible values for the type DaReceptors.
func DaReceptorsValues() []DaReceptors { return _DaReceptorsValues }

// Values returns all possible values for the type DaReceptors.
func (i DaReceptors) Values() []enums.Enum { return enums.Values(_DaReceptorsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i DaReceptors) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *DaReceptors) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "DaReceptors")
}

var _ValencesValues = []Valences{0, 1}

// ValencesN is the highest valid value for type Valences, plus one.
const ValencesN Valences = 2

var _ValencesValueMap = map[string]Valences{`Appetitive`: 0, `Aversive`: 1}

var _ValencesDescMap = map[Valences]string{0: `Appetititve is a positive valence US (food, water, etc)`, 1: `Aversive is a negative valence US (shock, threat etc)`}

var _ValencesMap = map[Valences]string{0: `Appetitive`, 1: `Aversive`}

// String returns the string representation of this Valences value.
func (i Valences) String() string { return enums.String(i, _ValencesMap) }

// SetString sets the Valences value from its string representation,
// and returns an error if the string is invalid.
func (i *Valences) SetString(s string) error {
	return enums.SetString(i, s, _ValencesValueMap, "Valences")
}

// Int64 returns the Valences value as an int64.
func (i Valences) Int64() int64 { return int64(i) }

// SetInt64 sets the Valences value from an int64.
func (i *Valences) SetInt64(in int64) { *i = Valences(in) }

// Desc returns the description of the Valences value.
func (i Valences) Desc() string { return enums.Desc(i, _ValencesDescMap) }

// ValencesValues returns all possible values for the type Valences.
func ValencesValues() []Valences { return _ValencesValues }

// Values returns all possible values for the type Valences.
func (i Valences) Values() []enums.Enum { return enums.Values(_ValencesValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Valences) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Valences) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "Valences") }

var _NeurFlagsValues = []NeurFlags{0, 1, 2, 3}

// NeurFlagsN is the highest valid value for type NeurFlags, plus one.
const NeurFlagsN NeurFlags = 4

var _NeurFlagsValueMap = map[string]NeurFlags{`NeurOff`: 0, `NeurHasExt`: 1, `NeurHasTarg`: 2, `NeurHasCmpr`: 3}

var _NeurFlagsDescMap = map[NeurFlags]string{0: `NeurOff flag indicates that this neuron has been turned off (i.e., lesioned)`, 1: `NeurHasExt means the neuron has external input in its Ext field`, 2: `NeurHasTarg means the neuron has external target input in its Targ field`, 3: `NeurHasCmpr means the neuron has external comparison input in its Targ field -- used for computing comparison statistics but does not drive neural activity ever`}

var _NeurFlagsMap = map[NeurFlags]string{0: `NeurOff`, 1: `NeurHasExt`, 2: `NeurHasTarg`, 3: `NeurHasCmpr`}

// String returns the string representation of this NeurFlags value.
func (i NeurFlags) String() string { return enums.BitFlagString(i, _NeurFlagsValues) }

// BitIndexString returns the string representation of this NeurFlags value
// if it is a bit index value (typically an enum constant), and
// not an actual bit flag value.
func (i NeurFlags) BitIndexString() string { return enums.String(i, _NeurFlagsMap) }

// SetString sets the NeurFlags value from its string representation,
// and returns an error if the string is invalid.
func (i *NeurFlags) SetString(s string) error { *i = 0; return i.SetStringOr(s) }

// SetStringOr sets the NeurFlags value from its string representation
// while preserving any bit flags already set, and returns an
// error if the string is invalid.
func (i *NeurFlags) SetStringOr(s string) error {
	return enums.SetStringOr(i, s, _NeurFlagsValueMap, "NeurFlags")
}

// Int64 returns the NeurFlags value as an int64.
func (i NeurFlags) Int64() int64 { return int64(i) }

// SetInt64 sets the NeurFlags value from an int64.
func (i *NeurFlags) SetInt64(in int64) { *i = NeurFlags(in) }

// Desc returns the description of the NeurFlags value.
func (i NeurFlags) Desc() string { return enums.Desc(i, _NeurFlagsDescMap) }

// NeurFlagsValues returns all possible values for the type NeurFlags.
func NeurFlagsValues() []NeurFlags { return _NeurFlagsValues }

// Values returns all possible values for the type NeurFlags.
func (i NeurFlags) Values() []enums.Enum { return enums.Values(_NeurFlagsValues) }

// HasFlag returns whether these bit flags have the given bit flag set.
func (i *NeurFlags) HasFlag(f enums.BitFlag) bool { return enums.HasFlag((*int64)(i), f) }

// SetFlag sets the value of the given flags in these flags to the given value.
func (i *NeurFlags) SetFlag(on bool, f ...enums.BitFlag) { enums.SetFlag((*int64)(i), on, f...) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i NeurFlags) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *NeurFlags) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "NeurFlags")
}

var _PathTypesValues = []PathTypes{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

// PathTypesN is the highest valid value for type PathTypes, plus one.
const PathTypesN PathTypes = 11

var _PathTypesValueMap = map[string]PathTypes{`ForwardPath`: 0, `BackPath`: 1, `LateralPath`: 2, `InhibPath`: 3, `CTCtxtPath`: 4, `CHLPath`: 5, `EcCa1Path`: 6, `RWPath`: 7, `TDRewPredPath`: 8, `MatrixPath`: 9, `GPiThalPath`: 10}

var _PathTypesDescMap = map[PathTypes]string{0: `Forward is a feedforward, bottom-up pathway from sensory inputs to higher layers`, 1: `Back is a feedback, top-down pathway from higher layers back to lower layers`, 2: `Lateral is a lateral pathway within the same layer / area`, 3: `Inhib is an inhibitory pathway that drives inhibitory synaptic conductances instead of the default excitatory ones.`, 4: `CTCtxt are pathways from Superficial layers to CT layers that send Burst activations drive updating of CtxtGe excitatory conductance, at end of plus (51B Bursting) phase. Biologically, this pathway comes from the PT layer 5IB neurons, but it is simpler to use the Super neurons directly, and PT are optional for most network types. These pathways also use a special learning rule that takes into account the temporal delays in the activation states. Can also add self context from CT for deeper temporal context.`, 5: `CHLPath implements Contrastive Hebbian Learning.`, 6: `EcCa1Path implements special learning for EC &lt;-&gt; CA1 pathways in the hippocampus to perform error-driven learning of this encoder pathway according to the ThetaPhase algorithm. uses Contrastive Hebbian Learning (CHL) on ActP - ActQ1 Q1: ECin -&gt; CA1 -&gt; ECout : ActQ1 = minus phase for auto-encoder Q2, 3: CA3 -&gt; CA1 -&gt; ECout : ActM = minus phase for recall Q4: ECin -&gt; CA1, ECin -&gt; ECout : ActP = plus phase for everything`, 7: `RWPath does dopamine-modulated learning for reward prediction: Da * Send.Act Use in RWPredLayer typically to generate reward predictions. Has no weight bounds or limits on sign etc.`, 8: `TDRewPredPath does dopamine-modulated learning for reward prediction: DWt = Da * Send.ActQ0 (activity on *previous* timestep) Use in TDRewPredLayer typically to generate reward predictions. Has no weight bounds or limits on sign etc.`, 9: `MatrixPath does dopamine-modulated, gated trace learning, for Matrix learning in PBWM context.`, 10: `GPiThalPath accumulates per-path raw conductance that is needed for separately weighting NoGo vs. Go inputs.`}

var _PathTypesMap = map[PathTypes]string{0: `ForwardPath`, 1: `BackPath`, 2: `LateralPath`, 3: `InhibPath`, 4: `CTCtxtPath`, 5: `CHLPath`, 6: `EcCa1Path`, 7: `RWPath`, 8: `TDRewPredPath`, 9: `MatrixPath`, 10: `GPiThalPath`}

// String returns the string representation of this PathTypes value.
func (i PathTypes) String() string { return enums.String(i, _PathTypesMap) }

// SetString sets the PathTypes value from its string representation,
// and returns an error if the string is invalid.
func (i *PathTypes) SetString(s string) error {
	return enums.SetString(i, s, _PathTypesValueMap, "PathTypes")
}

// Int64 returns the PathTypes value as an int64.
func (i PathTypes) Int64() int64 { return int64(i) }

// SetInt64 sets the PathTypes value from an int64.
func (i *PathTypes) SetInt64(in int64) { *i = PathTypes(in) }

// Desc returns the description of the PathTypes value.
func (i PathTypes) Desc() string { return enums.Desc(i, _PathTypesDescMap) }

// PathTypesValues returns all possible values for the type PathTypes.
func PathTypesValues() []PathTypes { return _PathTypesValues }

// Values returns all possible values for the type PathTypes.
func (i PathTypes) Values() []enums.Enum { return enums.Values(_PathTypesValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i PathTypes) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *PathTypes) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "PathTypes")
}

var _GateTypesValues = []GateTypes{0, 1, 2}

// GateTypesN is the highest valid value for type GateTypes, plus one.
const GateTypesN GateTypes = 3

var _GateTypesValueMap = map[string]GateTypes{`Maint`: 0, `Out`: 1, `MaintOut`: 2}

var _GateTypesDescMap = map[GateTypes]string{0: `Maint is maintenance gating -- toggles active maintenance in PFC.`, 1: `Out is output gating -- drives deep layer activation.`, 2: `MaintOut for maint and output gating.`}

var _GateTypesMap = map[GateTypes]string{0: `Maint`, 1: `Out`, 2: `MaintOut`}

// String returns the string representation of this GateTypes value.
func (i GateTypes) String() string { return enums.String(i, _GateTypesMap) }

// SetString sets the GateTypes value from its string representation,
// and returns an error if the string is invalid.
func (i *GateTypes) SetString(s string) error {
	return enums.SetString(i, s, _GateTypesValueMap, "GateTypes")
}

// Int64 returns the GateTypes value as an int64.
func (i GateTypes) Int64() int64 { return int64(i) }

// SetInt64 sets the GateTypes value from an int64.
func (i *GateTypes) SetInt64(in int64) { *i = GateTypes(in) }

// Desc returns the description of the GateTypes value.
func (i GateTypes) Desc() string { return enums.Desc(i, _GateTypesDescMap) }

// GateTypesValues returns all possible values for the type GateTypes.
func GateTypesValues() []GateTypes { return _GateTypesValues }

// Values returns all possible values for the type GateTypes.
func (i GateTypes) Values() []enums.Enum { return enums.Values(_GateTypesValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i GateTypes) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *GateTypes) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "GateTypes")
}
